<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAFIA: NEON CITY</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --surface-color: #16213e;
            --primary-color: #0f3460;
            --accent-color: #e94560;
            --glow-color: #ff7eee;
        }
        body { 
            font-family: 'Noto Sans KR', sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at 1px 1px, rgba(255,255,255,0.1) 1px, transparent 0);
            background-size: 20px 20px;
        }
        .font-orbitron { font-family: 'Orbitron', sans-serif; }
        .neon-text { text-shadow: 0 0 5px var(--glow-color), 0 0 10px var(--glow-color), 0 0 15px var(--glow-color); }
        .card {
            background-color: var(--surface-color);
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.3);
            transition: all 0.3s ease;
        }
        .btn-primary {
            background-color: var(--accent-color);
            color: white;
            font-weight: bold;
            border-radius: 8px;
            padding: 12px 24px;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px var(--accent-color);
        }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 0 20px var(--accent-color); }
        .chat-bubble { animation: fadeIn 0.5s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        /* 카드 뒤집기 애니메이션 */
        .role-card-container { perspective: 1000px; }
        .role-card {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.8s;
            transform-style: preserve-3d;
        }
        .role-card-container.flipped .role-card { transform: rotateY(180deg); }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 0.5rem;
        }
        .card-front { background-color: var(--primary-color); }
        .card-back { background-color: var(--surface-color); transform: rotateY(180deg); }
        [v-cloak] { display: none; }
    </style>
</head>
<body class="text-gray-200 flex items-center justify-center min-h-screen p-4">

    <div id="app" v-cloak class="w-full max-w-md mx-auto flex flex-col h-[95vh] space-y-4">
        <header class="text-center py-2">
            <h1 class="text-4xl font-orbitron neon-text text-white">MAFIA</h1>
            <p class="text-sm text-gray-400">NEON CITY</p>
        </header>

        <!-- 게임 상태 및 타이머 -->
        <div class="card p-4 text-center">
            <p class="font-bold text-lg text-white">{{ statusText }}</p>
            <p v-if="gameRoom.state === 'discussion'" class="font-orbitron text-3xl text-yellow-300 neon-text tracking-widest">{{ timerText }}</p>
        </div>

        <!-- 내 역할 -->
        <div v-if="amIPlayer && gameRoom.state !== 'waiting'" class="role-card-container h-28" :class="{ 'flipped': myRole }">
             <div class="role-card">
                <div class="card-face card-front">
                    <p class="font-bold text-lg">당신의 역할은?</p>
                    <p class="text-sm text-gray-300">확인 중...</p>
                </div>
                <div class="card-face card-back" :class="myRole === 'mafia' ? 'border-2 border-red-500' : 'border-2 border-cyan-400'">
                    <p class="text-sm">당신의 역할</p>
                    <p class="font-bold text-2xl" :class="myRole === 'mafia' ? 'text-red-500' : 'text-cyan-400'">{{ myRoleText }}</p>
                </div>
            </div>
        </div>

        <!-- 플레이어 목록 -->
        <div class="grid grid-cols-3 gap-3">
            <div v-for="player in playersWithDetails" :key="player.user_id" class="card p-3 text-center" :class="player.borderColor">
                <p class="font-semibold truncate text-white" :title="player.user_id">...{{ player.user_id.slice(-4) }}</p>
                <p v-if="player.roleText" class="text-xs" :class="player.roleColor">{{ player.roleText }}</p>
                <p v-if="player.voteCount > 0" class="text-xs text-yellow-400 mt-1">표: {{ player.voteCount }}</p>
                <button v-if="canVoteOn(player)" @click="castVote(player.user_id)" class="mt-2 w-full bg-red-600 hover:bg-red-700 text-white text-xs py-1 rounded-md transition-colors">지목</button>
            </div>
        </div>

        <!-- 채팅창 -->
        <div class="card flex-grow p-3 flex flex-col space-y-3 overflow-y-auto" id="chat-container">
            <div v-for="msg in messages" :key="msg.id" class="chat-bubble">
                <div v-if="msg.is_system_message" class="text-center text-sm text-yellow-300 italic">{{ msg.content }}</div>
                <div v-else class="flex items-end gap-2" :class="isMyMessage(msg.user_id) ? 'flex-row-reverse' : ''">
                    <div class="p-3 rounded-lg max-w-[80%]" :class="isMyMessage(msg.user_id) ? 'bg-indigo-600 text-white' : 'bg-gray-700 text-gray-200'">
                        <p class="font-bold text-sm" :class="isMyMessage(msg.user_id) ? 'text-right' : 'text-left'">{{ isMyMessage(msg.user_id) ? '나' : `...${msg.user_id.slice(-4)}` }}</p>
                        <p class="text-sm">{{ msg.content }}</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 입력 및 버튼 영역 -->
        <div>
            <div v-if="amIPlayer && gameRoom.state === 'discussion'" class="flex gap-2">
                <input type="text" v-model="chatMessage" @keyup.enter="sendMessage" class="flex-grow bg-gray-700 text-white rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="메시지 입력...">
                <button @click="sendMessage" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">전송</button>
            </div>
            <button v-if="canJoin" @click="joinGame" class="btn-primary w-full">게임 참가</button>
            <button v-if="canReset" @click="resetGame" class="btn-primary w-full bg-green-500">새 게임 시작</button>
        </div>
    </div>

    <script type="module">
        const { createClient } = supabase;
        const { createApp, reactive, toRefs, computed, onMounted, onUnmounted, nextTick } = Vue;

        const SUPABASE_URL = 'https://obbmtrxhmhokzvuxdqlc.supabase.co'; 
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9iYm10cnhobWhva3p2dXhkcWxjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk1MjE5MjEsImV4cCI6MjA2NTA5NzkyMX0.xBkkJ41u6mTLu2YaUtuWUxsv5PwyQR6yyMQNM6fAPfQ';
        const _supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        createApp({
            setup() {
                const state = reactive({
                    user: null, gameRoom: { state: 'waiting' }, players: [], messages: [], votes: [],
                    chatMessage: '', timerText: '02:00', gameTimer: null,
                });

                // --- Computed Properties ---
                const isMyMessage = (userId) => state.user && state.user.id === userId;
                const amIPlayer = computed(() => state.user && state.players.some(p => p.user_id === state.user.id));
                const canJoin = computed(() => state.user && !amIPlayer.value && state.gameRoom.state === 'waiting' && state.players.length < 3);
                const canReset = computed(() => state.user && state.gameRoom.state === 'finished' && state.gameRoom.can_reset_player_id === state.user.id);
                const myRole = computed(() => amIPlayer.value ? state.players.find(p => p.user_id === state.user.id)?.role : null);
                const myRoleText = computed(() => myRole.value === 'mafia' ? '마피아' : '시민');

                const statusText = computed(() => {
                    switch (state.gameRoom.state) {
                        case 'waiting': return `플레이어 대기 중... (${state.players.length}/3)`;
                        case 'discussion': return '마피아를 찾아라';
                        case 'voting': return '마피아라고 의심되는 사람을 지목하세요';
                        case 'finished': return `게임 종료: ${state.gameRoom.winner === 'citizens' ? '시민' : '마피아'} 승리!`;
                        default: return '연결 중...';
                    }
                });

                const playersWithDetails = computed(() => state.players.map(player => {
                    const isFinished = state.gameRoom.state === 'finished';
                    const isMafia = player.user_id === state.gameRoom.mafia_id;
                    return {
                        ...player,
                        voteCount: state.votes.filter(v => v.voted_for_user_id === player.user_id).length,
                        roleText: isFinished ? (isMafia ? '마피아' : '시민') : null,
                        roleColor: isFinished ? (isMafia ? 'text-red-400' : 'text-cyan-400') : '',
                        borderColor: isFinished ? (isMafia ? 'border-red-500' : 'border-cyan-400') : '',
                    };
                }));

                const canVoteOn = (player) => amIPlayer.value && state.gameRoom.state === 'voting' && player.user_id !== state.user.id && !state.votes.some(v => v.voter_user_id === state.user.id);

                // --- Methods ---
                const fetchAllGameState = async () => {
                    // 한 번의 요청으로 모든 관련 데이터를 가져옵니다.
                    const { data, error } = await _supabase.from('mafia_game_rooms').select(`
                        *,
                        mafia_players (*),
                        mafia_messages (*),
                        mafia_votes (*)
                    `).limit(1).single();

                    if (error) return console.error("게임 상태 로드 실패:", error);
                    
                    state.gameRoom = data;
                    state.players = data.mafia_players.sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
                    state.messages = data.mafia_messages.sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
                    state.votes = data.mafia_votes;
                    
                    updateTimer();
                    scrollToBottom();
                };

                const joinGame = async () => {
                    if (!state.user || !state.gameRoom) return;
                    const { error } = await _supabase.from('mafia_players').insert({ user_id: state.user.id, game_room_id: state.gameRoom.id });
                    if (error) console.error("참가 실패:", error);
                };

                const sendMessage = async () => {
                    if (state.chatMessage.trim() === '') return;
                    const content = state.chatMessage;
                    state.chatMessage = '';
                    const { error } = await _supabase.from('mafia_messages').insert({ user_id: state.user.id, game_room_id: state.gameRoom.id, content: content });
                    if (error) console.error("전송 실패:", error);
                };
                
                const castVote = async (targetUserId) => {
                    const { error } = await _supabase.from('mafia_votes').insert({ voter_user_id: state.user.id, voted_for_user_id: targetUserId, game_room_id: state.gameRoom.id });
                    if (error) console.error("투표 실패:", error);
                };

                const resetGame = async () => {
                    const { error } = await _supabase.rpc('reset_game', { room_id: state.gameRoom.id });
                    if (error) console.error("리셋 실패:", error);
                };

                const updateTimer = () => {
                    clearInterval(state.gameTimer);
                    if (state.gameRoom.state !== 'discussion' || !state.gameRoom.timer_end_time) return;
                    
                    state.gameTimer = setInterval(() => {
                        const remaining = Math.max(0, new Date(state.gameRoom.timer_end_time).getTime() - Date.now());
                        const minutes = Math.floor(remaining / 60000);
                        const seconds = Math.floor((remaining % 60000) / 1000);
                        state.timerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                        if (remaining <= 0) clearInterval(state.gameTimer);
                    }, 1000);
                };
                
                const scrollToBottom = () => nextTick(() => {
                    const el = document.getElementById('chat-container');
                    if (el) el.scrollTop = el.scrollHeight;
                });

                // --- Lifecycle Hooks ---
                onMounted(async () => {
                    const { data: { user } } = await _supabase.auth.getUser();
                    if (user) {
                        state.user = user;
                    } else {
                        const { data, error } = await _supabase.auth.signInAnonymously();
                        if (error) console.error("익명 로그인 실패", error);
                        else state.user = data.user;
                    }

                    await fetchAllGameState();
                    
                    const channel = _supabase.channel('public:mafia-game')
                        .on('postgres_changes', { event: '*', schema: 'public' }, fetchAllGameState)
                        .subscribe();

                    onUnmounted(() => _supabase.removeChannel(channel));
                });

                return { ...toRefs(state), isMyMessage, amIPlayer, canJoin, canReset, myRole, myRoleText, statusText, playersWithDetails, canVoteOn, joinGame, sendMessage, castVote, resetGame };
            }
        }).mount('#app');
    </script>
</body>
</html>

